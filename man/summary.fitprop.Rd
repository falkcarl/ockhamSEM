% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitprop.R
\name{summary.fitprop}
\alias{summary.fitprop}
\title{Summary function for fitprop objects}
\usage{
\method{summary}{fitprop}(
  object,
  ...,
  probs = seq(0, 1, 0.1),
  samereps = TRUE,
  lower.tail = rep(TRUE, ncol(object$fit_list[[1]])),
  NML = FALSE,
  UIF = FALSE
)
}
\arguments{
\item{object}{Object of class fitprop, as created by \code{\link[ockhamSEM]{run.fitprop}} function.}

\item{...}{Does nothing but to hopefully make this generic function pass R CMD check.}

\item{probs}{Vector passed to quantile to determine what probabilities to report.}

\item{samereps}{Logical value indicating whether to use only results from replications in which all selected models yielded results.}

\item{lower.tail}{Logical vector indicating whether lower values of each fit index corresponds to good fit.}

\item{NML}{(experimental) Logical value indicating whether to compute normalized maximum likelihood (NML; e.g., Rissanen, 2001). Requires
that `logl` is a saved fit index.}

\item{UIF}{(experimental) Logical value indicating whether to compute uniform index of fit (UIF; Botha, Shapiro, Steiger, 1988).
Original paper appeared to use least-squares estimation and compute UIF based on proportion of times that obtained fit function
was better than fit function based on random data. Currently this option works for any fit index, but some may make sense more
than others. Also requires \code{lower.tail} is appropriately set.}
}
\description{
Summary function for fitprop objects
}
\examples{
\donttest{

# Borrow PoliticalDemocracy data
data(PoliticalDemocracy)

# Define and fit two models using lavaan package
mod1a <- 'y5 ~ y1 + x1
  y1 ~~ 0*x1'
mod2a <- 'y5 ~ y1
  x1 ~ y5'

mod1a.fit <- sem(mod1a, sample.cov=cov(PoliticalDemocracy), sample.nobs=500)
mod2a.fit <- sem(mod2a, sample.cov=cov(PoliticalDemocracy), sample.nobs=500)

# Run fit propensity analysis
# Onion approach, save srmr and CFI
res <- run.fitprop(mod1a.fit, mod2a.fit, fit.measure=c("srmr","cfi"),
  rmethod="onion",reps=1000)

# Generate summaries
summary(res)

# sort quantiles differently for srmr and cfi
# Use different quantiles
summary(res, probs = c(0,.25,.5,.75,1), lower.tail=c(TRUE,FALSE))

# If some models failed to converge, this would result in
# summaries computed on possibly different replications:
# Use different quantiles
summary(res, samereps=FALSE, lower.tail=c(TRUE,FALSE))

# For computing NML (experimental)
res <- run.fitprop(mod1a.fit, mod2a.fit, fit.measure="logl",
  rmethod="onion",reps=2500)

summary(res, NML=TRUE, lower.tail=FALSE)

# For computing UIF (experimental)
# Orig UIF used least-squares estimation and examined fit function

mod1a.fit <- sem(mod1a, sample.cov=cov(PoliticalDemocracy), sample.nobs=500,
  estimator="ULS")
mod2a.fit <- sem(mod2a, sample.cov=cov(PoliticalDemocracy), sample.nobs=500,
  estimator="ULS")

res <- run.fitprop(mod1a.fit, mod2a.fit, fit.measure="fmin",
  rmethod="onion",reps=2500)

summary(res, UIF=TRUE, lower.tail=TRUE)



}
}
\references{
Botha, J.D., Shapiro, A., \& Steiger, J.H. (1988). Uniform indices-of-fit for factor analysis models. Multivariate Behavioral Research, 23(4), 443-450. \url{http://doi.org/10.1207/s15327906mbr2304_2}

Rissanen, J. (2001). Strong optimality of the normalized ML models as universal codes and information in data. IEEE Transactions on Information Theory, 47, 1712â€“1717.
}
